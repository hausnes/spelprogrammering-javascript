<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">

    <script src="globals.js"></script>
    <script src="classes.js"></script>
    <script src="map.js"></script>
    <script src="encounters.js"></script>

    <script type="text/javascript">
        var mapTileData = new TileMap();
        var player = new Character();
        var viewport = new Viewport();

        window.onload = function () {
            ctx = document.getElementById('game').getContext("2d");
            requestAnimationFrame(drawGame);
            ctx.font = "bold 10pt sans-serif";

            window.addEventListener("keydown", function (e) {
                if (e.keyCode >= 37 && e.keyCode <= 40) {
                    keysDown[e.keyCode] = true;
                }
                if (e.keyCode == 80) {
                    keysDown[e.keyCode] = true;
                }
            });
            window.addEventListener("keyup", function (e) {
                if (e.keyCode >= 37 && e.keyCode <= 40) {
                    keysDown[e.keyCode] = false;
                }
                if (e.keyCode == 83) {
                    currentSpeed = (currentSpeed >= (gameSpeeds.length - 1) ? 0 : currentSpeed + 1);
                }
                if (e.keyCode == 80) {
                    keysDown[e.keyCode] = false;
                }
            });

            viewport.screen = [document.getElementById('game').width,
                document.getElementById('game').height
            ];

            tileset = new Image();
            tileset.onerror = function () {
                ctx = null;
                alert("Failed loading tileset.");
            };
            tileset.onload = function () {
                tilesetLoaded = true;
            };
            tileset.src = tilesetURL;



            mapTileData.buildMapFromData(gameMap, mapW, mapH);
            mapTileData.addRoofs(roofList);
            mapTileData.map[((2 * mapW) + 2)].eventEnter = function () {
                var encounter = new Encounter("vakt");
                encounter.startEncounter();


            };



            var vakt = new MapObject(4);
            vakt.placeAt(2, 2);
            var mo2 = new MapObject(2);
            mo2.placeAt(2, 3);

            var mo11 = new MapObject(1);
            mo11.placeAt(6, 4);
            var mo12 = new MapObject(2);
            mo12.placeAt(7, 4);

            var mo4 = new MapObject(3);
            mo4.placeAt(4, 5);
            var mo5 = new MapObject(3);
            mo5.placeAt(4, 8);
            var mo6 = new MapObject(3);
            mo6.placeAt(4, 11);

            var mo7 = new MapObject(3);
            mo7.placeAt(2, 6);
            var mo8 = new MapObject(3);
            mo8.placeAt(2, 9);
            var mo9 = new MapObject(3);
            mo9.placeAt(2, 12);

            for (var i = 3; i < 8; i++) {
                var ps = new PlacedItemStack(1, 1);
                ps.placeAt(i, 1);
            }
            for (var i = 3; i < 8; i++) {
                var ps = new PlacedItemStack(1, 1);
                ps.placeAt(3, i);
            }
        };

        function drawGame() {
            if (ctx == null) {
                return;
            }
            if (!tilesetLoaded) {
                requestAnimationFrame(drawGame);
                return;
            }

            var currentFrameTime = Date.now();
            var timeElapsed = currentFrameTime - lastFrameTime;
            gameTime += Math.floor(timeElapsed * gameSpeeds[currentSpeed].mult);

            var sec = Math.floor(Date.now() / 1000);
            if (sec != currentSecond) {
                currentSecond = sec;
                framesLastSecond = frameCount;
                frameCount = 1;
            } else {
                frameCount++;
            }

            if (!player.processMovement(gameTime) && gameSpeeds[currentSpeed].mult != 0) {
                if (keysDown[38] && player.canMoveUp()) {
                    player.moveUp(gameTime);
                } else if (keysDown[40] && player.canMoveDown()) {
                    player.moveDown(gameTime);
                } else if (keysDown[37] && player.canMoveLeft()) {
                    player.moveLeft(gameTime);
                } else if (keysDown[39] && player.canMoveRight()) {
                    player.moveRight(gameTime);
                } else if (keysDown[80]) {
                    player.pickUp();
                }
            }

            viewport.update(player.position[0] + (player.dimensions[0] / 2),
                player.position[1] + (player.dimensions[1] / 2));

            var playerRoof1 = mapTileData.map[toIndex(
                player.tileFrom[0], player.tileFrom[1])].roof;
            var playerRoof2 = mapTileData.map[toIndex(
                player.tileTo[0], player.tileTo[1])].roof;

            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, viewport.screen[0], viewport.screen[1]);

            for (var z = 0; z < mapTileData.levels; z++) {

                for (var y = viewport.startTile[1]; y <= viewport.endTile[1]; ++y) {
                    for (var x = viewport.startTile[0]; x <= viewport.endTile[0]; ++x) {
                        if (z == 0) {
                            tileTypes[mapTileData.map[toIndex(x, y)].type].sprite.draw(
                                gameTime,
                                viewport.offset[0] + (x * tileW),
                                viewport.offset[1] + (y * tileH));
                        } else if (z == 1) {
                            var is = mapTileData.map[toIndex(x, y)].itemStack;
                            if (is != null) {
                                itemTypes[is.type].sprite.draw(
                                    gameTime,
                                    viewport.offset[0] + (x * tileW) + itemTypes[is.type].offset[0],
                                    viewport.offset[1] + (y * tileH) + itemTypes[is.type].offset[1]);
                            }
                        }

                        var o = mapTileData.map[toIndex(x, y)].object;
                        if (o != null && objectTypes[o.type].zIndex == z) {
                            var ot = objectTypes[o.type];

                            ot.sprite.draw(gameTime,
                                viewport.offset[0] + (x * tileW) + ot.offset[0],
                                viewport.offset[1] + (y * tileH) + ot.offset[1]);
                        }

                        if (z == 2 &&
                            mapTileData.map[toIndex(x, y)].roofType != 0 &&
                            mapTileData.map[toIndex(x, y)].roof != playerRoof1 &&
                            mapTileData.map[toIndex(x, y)].roof != playerRoof2) {
                            tileTypes[mapTileData.map[toIndex(x, y)].roofType].sprite.draw(
                                gameTime,
                                viewport.offset[0] + (x * tileW),
                                viewport.offset[1] + (y * tileH));
                        }
                    }
                }

                if (z == 1) {
                    player.sprites[player.direction].draw(
                        gameTime,
                        viewport.offset[0] + player.position[0],
                        viewport.offset[1] + player.position[1]);
                }

            }

            ctx.textAlign = "right";

            for (var i = 0; i < player.inventory.spaces; i++) {
                ctx.fillStyle = "#ddccaa";
                ctx.fillRect(10 + (i * 50), 350,
                    40, 40);

                if (typeof player.inventory.stacks[i] != 'undefined') {
                    var it = itemTypes[player.inventory.stacks[i].type];

                    it.sprite.draw(gameTime,
                        10 + (i * 50) + it.offset[0],
                        350 + it.offset[1]);

                    if (player.inventory.stacks[i].qty > 1) {
                        ctx.fillStyle = "#000000";
                        ctx.fillText("" + player.inventory.stacks[i].qty,
                            10 + (i * 50) + 38,
                            350 + 38);
                    }
                }
            }
            ctx.textAlign = "left";

            ctx.fillStyle = "#ff0000";
            ctx.fillText("FPS: " + framesLastSecond, 10, 20);
            ctx.fillText("Game speed: " + gameSpeeds[currentSpeed].name, 10, 40);
            player.displayInfo();
            lastFrameTime = currentFrameTime;
            requestAnimationFrame(drawGame);
        }
    </script>

</head>

<body>

    <div id="wrapper">

        <div id="tittel">

        </div>

        <div id="spel">
            <canvas id="game" width="800" height="400"></canvas>

        </div>

        <div id="inventory">

        </div>

        <div id="karakter">
            <p>
                <span id="str"></span><br>
                <span id="dex"></span><br>
                <span id="con"></span><br>
                <span id="visdom"></span><br>
                <span id="int"></span><br>
                <span id="cha"></span><br>
            </p>

        </div>

        <div id="footer">

        </div>



    </div>




</body>

</html>